function [Te_matrix_eV, ne_matrix, R_values, time_values, matFileName] = process_triple_probe_data(date, filepath, DOCID, shotlist, params, case_name)
% processTripleProbeData: トリプルプローブの生データを処理し、Teとneの2次元データを計算します。
%
%   入力:
%       date        - データの日付 (e.g., 240610)
%       filepath    - 生データファイルのパス
%       DOCID       - GoogleスプレッドシートのID
%       shotlist    - 処理するショット番号のリスト
%       params      - 計算に必要な物理定数や設定を含む構造体
%       case_name   - ケース名 (e.g., 'Case-I', 'Case-O')
%
%   出力:
%       Te_matrix_eV - 電子温度の2次元行列 [行:R、列:時間] (単位: eV)
%       ne_matrix    - 電子密度の2次元行列 [行:R、列:時間] (単位: m^-3)
%       R_values     - 各R位置のリスト [m]
%       time_values  - 統一された時間軸のリスト [us]
%       matFileName  - 保存されたMATファイルの完全パス

% パラメータの展開
Vd2 = params.V2;
Vd3 = params.V3;
A = params.A;
S_probe = params.S_probe;
time_us = params.time_us_unified;
time_slice_indices = params.time_slice_indices; % 例: 4700:5500
current_noise_threshold = params.current_noise_threshold; % 例: 1e-6
smoothing_window = params.smoothing_window; % 例: 10

% 物理定数
q = 1.60217663e-19; % 電子電荷
kb = 1.380649e-23; % ボルツマン定数
K2ev = 11604.5250061657; % kelvin to eV
mi = A * 1.66054e-27; % イオン質量

% スプレッドシートからR方向データを取得
try
    T = getTS6log(DOCID);
    T = searchlog(T, 'date', date);
    shot_indices = arrayfun(@(x) find(T.shot == x, 1), shotlist);
    r_list = T.tripleProbeRPosition_cm_(shot_indices) * 1e-2; % R座標[m]
catch ME
    error('Failed to access Google Sheet or find data: %s', ME.message);
end

% 時間データの統一と行列初期化
num_shots = length(shotlist);
Te_matrix = zeros(num_shots, length(time_us)); % Teデータ格納 (K)
ne_matrix = zeros(num_shots, length(time_us)); % neデータ格納 (m^-3)

% シンボリック変数宣言
[I1, I2, I3, Te, ne] = deal(sym('I1'), sym('I2'), sym('I3'), sym('Te'), sym('ne'));

% Te解法 [K]
eqn_Te = (I1 + I2) / (I1 + I3) == ...
    (1 - exp(-q * Vd2 / (kb * Te))) / (1 - exp(-q * Vd3 / (kb * Te)));
Te_symbolic = solve(eqn_Te, Te);

% ne解法 [m^-3]
eqn_ne = exp(-0.5) * S_probe * ne * q * sqrt(kb * Te / mi) == ...
    (I3 - I2 * exp(-q * (Vd3 - Vd2) / (kb * Te))) / (1 - exp(-q * (Vd3 - Vd2) / (kb * Te)));
ne_symbolic = solve(eqn_ne, ne);

% ショットごとのデータ読み込みと計算
valid_idx_counter = 0; % 有効なショット数カウンタ
for idx = 1:num_shots
    shot = shotlist(idx);
    filename = fullfile(filepath, num2str(date), ['ES_', num2str(date), sprintf('%03d', shot), '.csv']);

    if exist(filename, 'file')
        valid_idx_counter = valid_idx_counter + 1;
        % データ読み込み (時間範囲はファイルに合わせて調整)
        data = readmatrix(filename);
        time = data(time_slice_indices, 1); % 時間データ
        I2_values = data(time_slice_indices, 36); % 列36のデータ
        I3_values = data(time_slice_indices, 37); % 列37のデータ

        % 1. 初期ノイズ除去
        I2_values(abs(I2_values) < current_noise_threshold) = NaN;
        I3_values(abs(I3_values) < current_noise_threshold) = NaN;

        % 2. 欠損データの線形補間と適度な平滑化
        I2_values = fillmissing(I2_values, 'linear');
        I3_values = fillmissing(I3_values, 'linear');
        I2_values = smoothdata(I2_values, 'movmedian', smoothing_window);
        I3_values = smoothdata(I3_values, 'movmedian', smoothing_window);
        I1_values = I2_values + I3_values;

        % 3. Te[K] 計算
        try
            I1_calc = I1_values; I2_calc = I2_values; I3_calc = I3_values;
            % ゼロ除算やlogの不正な引数をチェックしてNaNにする
            ratio_arg = (I1_calc + I3_calc) ./ (I2_calc - I3_calc);
            problem_indices = (abs(I2_calc - I3_calc) < 1e-12) | (ratio_arg <= 0);
            I1_calc(problem_indices) = NaN;
            I2_calc(problem_indices) = NaN;
            I3_calc(problem_indices) = NaN;

            Te_values_K = real(double(subs(Te_symbolic, {I1, I2, I3}, {I1_calc, I2_calc, I3_calc})));
            Te_values_K(Te_values_K < 0 | Te_values_K > 100 * K2ev) = NaN; % 物理的にありえない値を除外
        catch
            Te_values_K = NaN(size(I1_values));
        end

        % ne[m^-3] 計算
        try
            ne_values = real(double(subs(ne_symbolic, {Te, I2, I3}, {Te_values_K, I2_values, I3_values})));
            ne_values(ne_values < 0) = NaN;
        catch
            ne_values = NaN(size(I2_values));
        end

        % 補間して時間軸を統一
        Te_matrix(valid_idx_counter, :) = interp1(time, Te_values, time_us, 'linear', NaN);
        ne_matrix(valid_idx_counter, :) = interp1(time, ne_values, time_us, 'linear', NaN);
    else
        warning('File %s not found. Skipping shot %d.', filename, shot);
    end
end

% 有効データのみを使用 (NaNを含む行は除く前に補完)
Te_matrix = Te_matrix(1:valid_idx_counter, :);
ne_matrix = ne_matrix(1:valid_idx_counter, :);
r_list = r_list(1:valid_idx_counter);

% NaN値を補完 (R方向で線形補完) - ショット間のばらつきを考慮し、時間方向に補間してからR方向を補完
Te_matrix = fillmissing(Te_matrix, 'linear', 1); % R方向に補間
ne_matrix = fillmissing(ne_matrix, 'linear', 1); % R方向に補間
Te_matrix = fillmissing(Te_matrix, 'linear', 2); % 時間方向に補間
ne_matrix = fillmissing(ne_matrix, 'linear', 2); % 時間方向に補間

% 同じr_listの値でTeとneの平均値を計算
R_values = unique(r_list); % 一意なR値
Te_avg_matrix = zeros(length(R_values), length(time_us));
ne_avg_matrix = zeros(length(R_values), length(time_us));

for i = 1:length(R_values)
    idx_r = (r_list == R_values(i)); % 現在のR値に対応するインデックス
    Te_avg_matrix(i, :) = mean(Te_matrix(idx_r, :), 1, 'omitnan'); % 平均
    ne_avg_matrix(i, :) = mean(ne_matrix(idx_r, :), 1, 'omitnan'); % 平均
end

% Teを[K]から[eV]に変換
Te_matrix_eV = Te_avg_matrix ./ K2ev;

time_values = time_us; % 統一された時間軸を出力変数に設定

%% MATファイルの作製
targetFolderPath = fullfile('C:\\Users\\w-har\\OneDrive - The University of Tokyo\\Lab\\pcb_experiment\\triple_probe\\mat\\', num2str(date));

if ~exist(targetFolderPath, 'dir')
    mkdir(targetFolderPath);
end

% ファイル名の動的決定
matFileName = fullfile(targetFolderPath, ['triple_data2D_', case_name, '.mat']);

% 3次元データ構造を作成 (squeezeに対応するため、サイズ調整)
triple_data2D = struct();
triple_data2D.Te = reshape(Te_matrix_eV, [length(R_values), 1, length(time_values)]);
triple_data2D.ne = reshape(ne_avg_matrix, [length(R_values), 1, length(time_values)]);

% 指定したパスにMATファイルを保存
save(matFileName, 'triple_data2D', 'R_values', 'time_values');

disp(['MATファイル ', matFileName, ' を保存しました。']);

end